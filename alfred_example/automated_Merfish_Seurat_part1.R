library(Seurat)
library(dplyr)
library(Matrix)
library(reticulate)
# install.packages('BiocManager')
# BiocManager::install('limma')

#setwd('/home/alfred/Dropbox/schafer_lab_simkin/merfish/merfish_seurat/seurat_dockerfile')

options(scipen = 100)

###################
# read in data. merged_metadata_and_partitions.csv is generated by adding the the columns of features_metadata.csv to barcodes_per_feature.csv 
print("reading in the table")
OB <- read.table(file = 'Mouse_Brain_M22_210405_merged_metadata_and_partitions.csv',sep=",", header = TRUE, row.names=1)
#find which cells are larger than 50
Big.Cells1 <- which(OB['volume']>= 50)
OB <- OB[Big.Cells1,]
#get positional stats of every cell as scalars
volume1<-OB$volume
center.x<-OB$center_x
center.y<-OB$center_y
#center.y<-setNames(center.y, rownames(OB))

# transpose so rows are genes and columns are cells.
OB <- t(OB)

#view all the names of the rows (so human can double check the loop below)
OB_rows=rownames(OB)
rownames(OB)

# loop through the rows and store row number of first "Blank" gene as a counter
counter=0
for (val in OB_rows)
{
  if (grepl('Blank', val, fixed = TRUE))
  {
    break
  }
  counter=counter+1
}
print(counter)

#trim off all rows that come after the counter
OB <- OB[1:counter,]

#check that cutpoint was correct (compare against output of rownames(OB) above)
rownames(OB)
#write.csv(OB,"experimental.csv", row.names = TRUE)

# normalize gene counts by cell volume
OB <- OB/volume1
#make seurat object
OB_s <- CreateSeuratObject(counts = OB)
# add metadata for vol, X, y
Volumes <- data.frame(volume1)
Center.x <- data.frame(center.x)
Center.y <- data.frame(center.y)
#add volumes, center of x and center of y to metadata of seurat object
OB_s@meta.data <- cbind(OB_s@meta.data,Volumes)
OB_s@meta.data <- cbind(OB_s@meta.data,Center.x)
OB_s@meta.data <- cbind(OB_s@meta.data,Center.y)

# Repeat for each dataset  ###is this 'repeat' step in the code or does the code need to be edited each time for each sample?
#####################

#create condition and sample metadata if combining multiple samples
OB_s$condition <- "OB"
#CFA_s$condition <- "CFA"
#CFA2_s$condition <- "CFA"
#OB2_s$condition <- "OB"
#CFA3_s$condition <- "CFA"

OB_s$sample <- "OB1"
#CFA_s$sample <- "CFA1"
#CFA2_s$sample <- "CFA2"
#OB2_s$sample <- "OB2"
#CFA3_s$sample <- "CFA3"
print(head(OB_s@meta.data, 5))
# #merge into single object if combining multiple samples
#OB.combined <- merge(OB_s, y = c(CFA_s, CFA2_s,OB2_s,CFA3_s), add.cell.ids = c("OB1", "CFA1", "CFA2","OB2","CFA3"))

#QC checks
VlnPlot(OB_s, features = c("nFeature_RNA", "nCount_RNA"), ncol = 2, pt.size = 0)

#remove non-cells
OB_s <- subset(OB_s,nCount_RNA >0.05 & nFeature_RNA > 10)

#normalize data
OB_s <-NormalizeData(OB_s)

#find variable features (I reduced from default of 2000 to 275 since only 275 genes in the panel)
OB_s <- FindVariableFeatures(OB_s, selection.method = "vst", nfeatures = counter)

#scale data and run PCA
print("running PCA")
all.genes <- rownames(OB_s)
OB_s <- ScaleData(OB_s, features = all.genes)
OB_s <- RunPCA(OB_s, features = VariableFeatures(object = OB_s),npcs = 40)

# #test of number of significant Principal Components
print("finding the number of principal components that contribute significantly to the data. This might take ~5 minutes")
OB_s <- JackStraw(OB_s, num.replicate = 100,dims=40)
OB_s <- ScoreJackStraw(OB_s, dims = 1:40)
JackStrawPlot(OB_s, dims = 1:40)
print("P-values from JackStraw plot are as follows")
print(OB_s@reductions$pca@jackstraw@overall.p.values)
#user needs to look at graph and decide this parameter - choosing only the top ___ significant components
cat("how many dimensions starting from dimension 1 would you like to use? Enter an integer:")
PCA_from_Jackstraw=20
#PCA_from_Jackstraw=readLines(file("stdin"), n=1)
#PCA_from_Jackstraw=as.integer(PCA_from_Jackstraw)
#user needs to set a desired resolution
cat("how aggressively would you like R to cluster the data? The more cells you have, the higher the resolution you might try. Values between 0.4 and 2.0 are approximately normal. Enter a decimal:")
Resolution_setting=1.8
#Resolution_setting=readLines(file("stdin"), n=1)
#Resolution_setting=as.double(Resolution_setting)
#cluster
OB_s <- FindNeighbors(OB_s, dims = 1:PCA_from_Jackstraw)
OB_s <- FindClusters(OB_s, resolution = Resolution_setting)
OB_s <- RunUMAP(OB_s, dims = 1:PCA_from_Jackstraw)
DimPlot(OB_s, reduction = "umap", label = TRUE)#+coord_fixed(ratio = 1)

#dot plot
#feature plot

# find markers for every cluster compared to all remaining cells, report only the positive ones
OB.markers <- FindAllMarkers(OB_s, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)

##plot XY of individual clusters
library(ggplot2)
cluster <- "3"
sampleA <- "OB1"
x0 <- OB_s$center.x[WhichCells(object = subset(OB_s,subset = sample ==sampleA), ident = cluster)]
y0 <- OB_s$center.y[WhichCells(object = subset(OB_s,subset = sample ==sampleA), ident = cluster)]
df<-data.frame(x0,y0)
ggplot(df,aes(x0,y0))+geom_point()+ggtitle(paste(sampleA,cluster,sep=" "))+ theme_linedraw()+coord_fixed(ratio = 1)+theme(legend.key.size = unit(2, 'cm'))
ggsave('cluster_3.pdf')

#print the names of the markers
options(max.print = 10000)
print(OB.markers[1:7])
print("Above are all the marker genes that are positively associated with your")
print("numbered clusters. Note that multiple clusters might have the same")
print("positively associated marker genes. By default, this program uses the")
print("marker genes you chose to label cell types, but we recommend downloading")
print("the images showing a. the level of expression of each marker gene in each")
print("cluster, b. the localization of each cluster in the original image, and c.")
print("looking into the genes that are positively associated with each cluster.")
print("You can optionally then manually assign labels to each cluster. To")
print("manually edit cluster labels, open a new terminal window, then use the command")
print("'micro actual_cluster_labels.txt' to edit the cluster labels, save with")
print("ctrl-S, and quit with ctrl-Q. if you think there are not enough clusters,")
print("you may also consider re-running this program using a")
print("higher resolution. When you're happy with the cluster labels, push the")
print("Enter button in this terminal window to continue.")

#output the markers to a tsv file for parsing (I use get_cluster_markers.py for this)
write.table(OB.markers, file='markers.tsv', quote=FALSE, sep='\t', col.names = NA)

saveRDS(OB_s, file = "OB_s_object.rds")
